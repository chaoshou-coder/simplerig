# language: zh-CN
# encoding: utf-8

功能: 统计报告
  作为一个开发者
  我希望在任务完成后看到详细的统计报告
  以便了解执行耗时和资源消耗

  背景:
    假如 SimpleRig 已正确安装
    并且 config.yaml 配置文件存在

  # ===========================================================================
  # 场景组 1: 基础统计功能
  # ===========================================================================

  场景: 运行完成后显示统计摘要
    假如 我执行 "simplerig run '实现功能'"
    当 工作流执行完成
    那么 应该显示统计报告
    并且 报告应包含 "总耗时"
    并且 报告应包含 "总 Token"
    并且 报告应包含 "阶段统计"

  场景: 统计报告显示各阶段耗时
    假如 我执行一个包含多阶段的工作流
    当 工作流执行完成
    那么 统计报告应包含以下阶段:
      | 阶段      | 字段     |
      | plan      | 耗时     |
      | develop   | 耗时     |
      | verify    | 耗时     |
      | integrate | 耗时     |

  场景: 统计报告显示各阶段 Token 消耗
    假如 我执行一个包含 LLM 调用的工作流
    当 工作流执行完成
    那么 每个阶段应显示:
      | 字段            | 说明           |
      | prompt_tokens   | 输入 token 数  |
      | completion_tokens | 输出 token 数 |
      | total_tokens    | 总 token 数    |

  场景: 统计报告显示任务级统计
    假如 工作流包含多个并行任务
    当 工作流执行完成
    那么 统计报告应包含每个任务的:
      | 字段       | 说明       |
      | task_id    | 任务标识   |
      | status     | 执行状态   |
      | duration_ms | 耗时毫秒  |
      | token_usage | Token 消耗 |

  # ===========================================================================
  # 场景组 2: stats 子命令
  # ===========================================================================

  场景: 查看最近一次运行统计
    假如 存在历史运行记录
    当 我执行 "simplerig stats"
    那么 应显示最近一次运行的统计报告

  场景: 查看指定运行的统计
    假如 存在运行 ID 为 "20260205_120000_abc123" 的记录
    当 我执行 "simplerig stats --run-id 20260205_120000_abc123"
    那么 应显示该运行的统计报告
    并且 报告中的 run_id 应为 "20260205_120000_abc123"

  场景: 以 JSON 格式输出统计
    假如 存在历史运行记录
    当 我执行 "simplerig stats --json"
    那么 输出应为有效的 JSON 格式
    并且 JSON 应包含以下字段:
      | 字段                    | 类型   |
      | run_id                  | string |
      | status                  | string |
      | total_duration_ms       | number |
      | total_duration_formatted | string |
      | total_token_usage       | object |
      | stages                  | object |
      | tasks                   | object |
      | event_count             | number |

  场景: 无运行记录时的错误提示
    假如 不存在任何运行记录
    当 我执行 "simplerig stats"
    那么 应显示错误信息 "未找到任何运行记录"
    并且 退出码应为 1

  场景: 指定的运行 ID 不存在
    假如 运行 ID "nonexistent_run" 不存在
    当 我执行 "simplerig stats --run-id nonexistent_run"
    那么 应显示错误信息 "运行不存在"
    并且 退出码应为 1

  # ===========================================================================
  # 场景组 3: 耗时格式化
  # ===========================================================================

  场景大纲: 耗时格式化显示
    当 耗时为 <毫秒数> 毫秒
    那么 应格式化显示为 "<格式化结果>"

    例子:
      | 毫秒数    | 格式化结果  |
      | 500       | 500ms       |
      | 1000      | 1.00s       |
      | 1500      | 1.50s       |
      | 59000     | 59.00s      |
      | 60000     | 1m 0.0s     |
      | 90000     | 1m 30.0s    |
      | 3600000   | 1h 0m       |
      | 5400000   | 1h 30m      |

  # ===========================================================================
  # 场景组 4: 统计数据持久化
  # ===========================================================================

  场景: 统计数据保存到 artifacts
    假如 我执行一个工作流
    当 工作流执行完成
    那么 应在 artifacts 目录下生成 "stats.json"
    并且 stats.json 应包含完整的统计数据

  场景: 从 events.jsonl 重建统计
    假如 存在运行目录包含 events.jsonl
    当 我调用 collect_stats(run_dir)
    那么 应返回 RunStats 对象
    并且 统计数据应与事件流一致

  # ===========================================================================
  # 场景组 5: Token 使用量累加
  # ===========================================================================

  场景: Token 使用量正确累加
    假如 阶段 A 消耗 100 tokens
    并且 阶段 B 消耗 200 tokens
    当 统计收集完成
    那么 总 token 消耗应为 300 tokens

  场景: 任务级 Token 也计入总量
    假如 阶段消耗 150 tokens
    并且 任务消耗 75 tokens
    当 统计收集完成
    那么 总 token 消耗应为 225 tokens

  # ===========================================================================
  # 场景组 6: 状态追踪
  # ===========================================================================

  场景: 追踪运行状态
    假如 工作流开始执行
    当 收到 run.started 事件
    那么 状态应为 "running"
    当 收到 run.completed 事件
    那么 状态应为 "completed"

  场景: 追踪失败状态
    假如 工作流执行失败
    当 收到 run.failed 事件
    那么 状态应为 "failed"
    并且 end_time 应被记录

  场景: 追踪阶段状态
    假如 阶段开始执行
    当 收到 stage.started 事件
    那么 该阶段状态应为 "running"
    当 收到 stage.completed 事件
    那么 该阶段状态应为 "completed"
    并且 duration_ms 应被记录

  场景: 追踪跳过的阶段
    假如 某阶段被跳过
    当 收到 stage.skipped 事件
    那么 该阶段状态应为 "skipped"
    并且 duration_ms 应为 0

  # ===========================================================================
  # 场景组 7: 边界情况
  # ===========================================================================

  场景: 处理空事件流
    假如 events.jsonl 为空
    当 调用 collect_stats
    那么 应返回默认的 RunStats
    并且 event_count 应为 0

  场景: 处理不完整的运行
    假如 运行被中断（无 run.completed 事件）
    当 调用 collect_stats
    那么 应使用最后一个事件的时间作为估算结束时间
    并且 状态应保持 "running"

  场景: 处理缺失的时间戳
    假如 事件缺少时间戳
    当 计算耗时
    那么 应返回 0 而非抛出异常

  # ===========================================================================
  # 场景组 8: API 集成
  # ===========================================================================

  场景: Python API 访问统计
    假如 我有一个 run_dir 路径
    当 我执行以下代码:
      """python
      from simplerig import collect_stats, format_duration
      
      stats = collect_stats(run_dir)
      print(stats.summary())
      print(stats.to_dict())
      """
    那么 应正常返回统计数据

  场景: TokenUsage 支持加法运算
    当 我执行以下代码:
      """python
      from simplerig import TokenUsage
      
      usage1 = TokenUsage(prompt_tokens=100, completion_tokens=50, total_tokens=150)
      usage2 = TokenUsage(prompt_tokens=200, completion_tokens=100, total_tokens=300)
      total = usage1 + usage2
      """
    那么 total.prompt_tokens 应为 300
    并且 total.completion_tokens 应为 150
    并且 total.total_tokens 应为 450

  # ===========================================================================
  # 场景组 9: 敏感数据保护
  # ===========================================================================

  场景: token_usage 字段不被脱敏
    假如 事件包含 token_usage 数据
    当 事件被写入 events.jsonl
    那么 token_usage 字段应保持原值
    并且 不应被替换为 "[REDACTED]"

  场景: 敏感 token 字段仍被脱敏
    假如 事件包含 api_token 或 secret_token 字段
    当 事件被写入 events.jsonl
    那么 这些字段应被替换为 "[REDACTED]"
